<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="shortcut icon" href="favicon.ico">
<title>俄罗斯方块</title>
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  
  body {
    background: linear-gradient(135deg, #111, #333);
    color: #eee;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    user-select: none;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
  }
  
  .game-container {
    display: flex;
    gap: 20px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.6);
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(5px);
  }
  
  canvas {
    background: #111;
    border: 2px solid #444;
    border-radius: 6px;
    image-rendering: pixelated;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
  }
  
  .sidebar {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 180px;
  }
  
  .panel {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    padding: 15px;
    border: 1px solid #444;
  }
  
  h2 {
    font-size: 1.2rem;
    margin-bottom: 10px;
    color: #fff;
    text-align: center;
    border-bottom: 1px solid #444;
    padding-bottom: 5px;
  }
  
  #score {
    font-size: 2rem;
    font-weight: bold;
    text-align: center;
    color: #ffcc00;
    text-shadow: 0 0 5px rgba(255, 204, 0, 0.5);
  }
  
  #next-piece {
    width: 100px;
    height: 100px;
    margin: 0 auto;
   display:block;
  }
  
  .controls {
    margin-top: 10px;
  }
  
  .controls p {
    margin: 5px 0;
    font-size: 0.9rem;
    color: #ccc;
  }
  
  .controls kbd {
    display: inline-block;
    padding: 2px 6px;
    background: #333;
    border-radius: 4px;
    border: 1px solid #555;
    font-size: 0.8rem;
  }
  
  .buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 15px;
  }
  
  button {
    padding: 8px 12px;
    background: linear-gradient(to bottom, #444, #222);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  button:hover {
    background: linear-gradient(to bottom, #555, #333);
    transform: translateY(-2px);
  }
  
  button:active {
    transform: translateY(0);
  }
  
  #pause-btn {
    background: linear-gradient(to bottom, #2980b9, #1a5276);
  }
  
  #restart-btn {
    background: linear-gradient(to bottom, #e74c3c, #c0392b);
  }
  
  #game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.85);
    padding: 30px;
    border-radius: 10px;
    text-align: center;
    display: none;
    z-index: 10;
    border: 2px solid #ffcc00;
    box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
  }
  
  #game-over h2 {
    color: #ffcc00;
    font-size: 2rem;
    margin-bottom: 20px;
  }
  
  #final-score {
    font-size: 1.5rem;
    margin-bottom: 20px;
    color: #fff;
  }
  
  .level-info {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
    color: #aaa;
    font-size: 0.9rem;
  }
  
  .particles {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: -1;
  }
  
  /* 移动端触摸控制按钮 */
  .mobile-controls {
    display: none;
    position: fixed;
    bottom: 20px;
    left: 0;
    width: 100%;
    padding: 10px;
    justify-content: space-around;
  }
  
  .mobile-btn {
    width: 70px;
    height: 70px;
    background: rgba(255, 255, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    color: white;
    user-select: none;
    touch-action: manipulation;
  }
  
  .mobile-btn:active {
    background: rgba(255, 255, 255, 0.3);
  }
  
  .mobile-drop {
    width: 100px;
    height: 70px;
    border-radius: 35px;
  }
  
  /* 响应式设计 */
  @media (max-width: 768px) {
    .game-container {
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    
    .sidebar {
      width: 100%;
      max-width: 300px;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .panel {
      flex: 1;
      min-width: 140px;
    }
    
    #next-piece {
      width: 80px;
      height: 80px;
    }
    
    .mobile-controls {
      display: flex;
    }
    
    body {
      overflow: auto;
    }
  }
  
  @media (max-height: 700px) and (orientation: landscape) {
    .game-container {
      transform: scale(0.9);
    }
  }
</style>
</head>
<body>
<div class="particles" id="particles"></div>

<div class="game-container">
  <canvas id="tetris" width="300" height="400"></canvas>
  
  <div class="sidebar">
    <div class="panel">
      <h2>得分</h2>
      <div id="score">0</div>
      <div class="level-info">
        <span>等级: <span id="level">1</span></span>
        <span>行数: <span id="lines">0</span></span>
      </div>
    </div>
    
    <div class="panel">
      <h2>下一个</h2>
      <canvas id="next-piece" width="100" height="100"></canvas>
    </div>
    
    <div class="panel">
      <h2>操作</h2>
      <div class="controls">
        <p><kbd>←</kbd> / <kbd>A</kbd> : 左移</p>
        <p><kbd>→</kbd> / <kbd>D</kbd> : 右移</p>
        <p><kbd>↑</kbd> / <kbd>W</kbd> : 旋转</p>
        <p><kbd>↓</kbd> / <kbd>S</kbd> : 加速下落</p>
        <p><kbd>Space</kbd> : 直接落底</p>
        <p><kbd>P</kbd> : 暂停/继续</p>
      </div>
      
      <div class="buttons">
        <button id="pause-btn">暂停/继续</button>
        <button id="restart-btn">重新开始</button>
      </div>
    </div>
  </div>
</div>

<!-- 移动端触摸控制按钮 -->
<div class="mobile-controls">
  <div class="mobile-btn" id="mobile-left">←</div>
  <div class="mobile-btn" id="mobile-rotate">↻</div>
  <div class="mobile-btn mobile-drop" id="mobile-drop">↓</div>
  <div class="mobile-btn" id="mobile-right">→</div>
</div>

<div id="game-over">
  <h2>游戏结束</h2>
  <div id="final-score">得分: 0</div>
  <button id="restart-btn-2">再玩一次</button>
</div>

<script>
(() => {
  // 创建背景粒子效果
  function createParticles() {
    const container = document.getElementById('particles');
    const count = 30;
    
    for (let i = 0; i < count; i++) {
      const particle = document.createElement('div');
      particle.style.position = 'absolute';
      particle.style.width = Math.random() * 3 + 1 + 'px';
      particle.style.height = particle.style.width;
      particle.style.background = `rgba(${Math.random() * 100 + 50}, ${Math.random() * 100 + 50}, ${Math.random() * 255}, ${Math.random() * 0.3 + 0.1})`;
      particle.style.borderRadius = '50%';
      particle.style.left = Math.random() * 100 + 'vw';
      particle.style.top = Math.random() * 100 + 'vh';
      
      container.appendChild(particle);
      
      // 添加动画
      particle.animate(
        [
          { transform: 'translateY(0)' },
          { transform: `translateY(${Math.random() * 100 - 50}vh)` }
        ],
        {
          duration: Math.random() * 10000 + 10000,
          iterations: Infinity,
          direction: 'alternate',
          easing: 'ease-in-out'
        }
      );
    }
  }
  
  createParticles();

  const canvas = document.getElementById('tetris');
  const context = canvas.getContext('2d');
  const nextPieceCanvas = document.getElementById('next-piece');
  const nextPieceContext = nextPieceCanvas.getContext('2d');
  
  // 根据新的画布尺寸300*400调整缩放比例
  // 画布是300*400，游戏区域是12列*20行，所以每格大约是25*20像素
  context.scale(25, 20);
  nextPieceContext.scale(20, 20);

  const scoreElem = document.getElementById('score');
  const levelElem = document.getElementById('level');
  const linesElem = document.getElementById('lines');
  const pauseBtn = document.getElementById('pause-btn');
  const restartBtn = document.getElementById('restart-btn');
  const restartBtn2 = document.getElementById('restart-btn-2');
  const gameOverElem = document.getElementById('game-over');
  const finalScoreElem = document.getElementById('final-score');

  // 移动端控制按钮
  const mobileLeft = document.getElementById('mobile-left');
  const mobileRight = document.getElementById('mobile-right');
  const mobileRotate = document.getElementById('mobile-rotate');
  const mobileDrop = document.getElementById('mobile-drop');

  // 俄罗斯方块形状和颜色
  const pieces = {
    'I': {
      shape: [
        [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
        [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]
      ],
      color: '#00f0f0'
    },
    'J': {
      shape: [
        [[1,0,0],[1,1,1],[0,0,0]],
        [[0,1,1],[0,1,0],[0,1,0]],
        [[0,0,0],[1,1,1],[0,0,1]],
        [[0,1,0],[0,1,0],[1,1,0]]
      ],
      color: '#0000f0'
    },
    'L': {
      shape: [
        [[0,0,1],[1,1,1],[0,0,0]],
        [[0,1,0],[0,1,0],[0,1,1]],
        [[0,0,0],[1,1,1],[1,0,0]],
        [[1,1,0],[0,1,0],[0,1,0]]
      ],
      color: '#f0a000'
    },
    'O': {
      shape: [[[1,1],[1,1]]],
      color: '#f0f000'
    },
    'S': {
      shape: [
        [[0,1,1],[1,1,0],[0,0,0]],
        [[0,1,0],[0,1,1],[0,0,1]]
      ],
      color: '#00f000'
    },
    'T': {
      shape: [
        [[0,1,0],[1,1,1],[0,0,0]],
        [[0,1,0],[0,1,1],[0,1,0]],
        [[0,0,0],[1,1,1],[0,1,0]],
        [[0,1,0],[1,1,0],[0,1,0]]
      ],
      color: '#a000f0'
    },
    'Z': {
      shape: [
        [[1,1,0],[0,1,1],[0,0,0]],
        [[0,0,1],[0,1,1],[0,1,0]],
      ],
      color: '#f00000'
    }
  };

  const COLS = 12;
  const ROWS = 20;

  function createMatrix(w, h) {
    const matrix = [];
    while (h--) {
      matrix.push(new Array(w).fill(0));
    }
    return matrix;
  }

  function drawMatrix(matrix, offset) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value) {
          context.fillStyle = value;
          context.fillRect(x + offset.x, y + offset.y, 1, 1);
          
          // 添加方块内部高光效果
          context.fillStyle = 'rgba(255, 255, 255, 0.2)';
          context.fillRect(x + offset.x, y + offset.y, 0.8, 0.2);
          context.fillRect(x + offset.x, y + offset.y, 0.2, 0.8);
          
          context.strokeStyle = '#111';
          context.lineWidth = 0.08;
          context.strokeRect(x + offset.x, y + offset.y, 1, 1);
        }
      });
    });
  }

  function drawNextPiece() {
    nextPieceContext.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
    nextPieceContext.fillStyle = '#111';
    nextPieceContext.fillRect(0, 0, 5, 5);
    
    if (nextPiece) {
      const offset = {
        x: (5 - nextPiece.matrix[0].length) / 2,
        y: (5 - nextPiece.matrix.length) / 2
      };
      
      nextPiece.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            nextPieceContext.fillStyle = nextPiece.color;
            nextPieceContext.fillRect(x + offset.x, y + offset.y, 1, 1);
            
            nextPieceContext.strokeStyle = '#111';
            nextPieceContext.lineWidth = 0.08;
            nextPieceContext.strokeRect(x + offset.x, y + offset.y, 1, 1);
          }
        });
      });
    }
  }

  function collide(arena, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; y++) {
      for (let x = 0; x < m[y].length; x++) {
        if (m[y][x] && 
          (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value) {
          arena[y + player.pos.y][x + player.pos.x] = player.color;
        }
      });
    });
  }

  function playerReset() {
    player.matrix = nextPiece.matrix.map(row => row.slice());
    player.color = nextPiece.color;
    player.type = nextPiece.type;
    player.shapeIndex = nextPiece.shapeIndex;
    
    player.pos.y = 0;
    player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0);

    // 生成下一个方块
    const pieceTypes = Object.keys(pieces);
    const type = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
    const piece = pieces[type];
    nextPiece = {
      matrix: piece.shape[0].map(row => row.slice()),
      color: piece.color,
      type: type,
      shapeIndex: 0
    };
    
    drawNextPiece();

    if (collide(arena, player)) {
      gameOver();
    }
  }

  function playerRotate(dir) {
    const posX = player.pos.x;
    let offset = 1;
    
    // 保存当前状态用于碰撞检测失败时恢复
    const originalMatrix = player.matrix.map(row => row.slice());
    const originalShapeIndex = player.shapeIndex;
    
    // 获取当前形状的所有可能方向
    const piece = pieces[player.type];
    player.shapeIndex = (player.shapeIndex + dir + piece.shape.length) % piece.shape.length;
    player.matrix = piece.shape[player.shapeIndex].map(row => row.slice());
    
    // 尝试墙踢（wall kick）
    while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      
      // 如果所有尝试都失败，恢复原始状态
      if (offset > player.matrix[0].length) {
        player.pos.x = posX;
        player.matrix = originalMatrix;
        player.shapeIndex = originalShapeIndex;
        break;
      }
    }
  }

  function arenaSweep() {
    let linesCleared = 0;
    outer: for (let y = arena.length - 1; y >= 0; y--) {
      for (let x = 0; x < arena[y].length; x++) {
        if (!arena[y][x]) {
          continue outer;
        }
      }
      
      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      y++;
      linesCleared++;
    }
    
    if (linesCleared > 0) {
      // 根据消除的行数计算得分
      const points = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4行对应的分数
      player.score += points[linesCleared] * player.level;
      player.lines += linesCleared;
      
      // 每清除10行升一级
      player.level = Math.floor(player.lines / 10) + 1;
      
      // 更新下落速度
      dropInterval = Math.max(100, 1000 - (player.level - 1) * 100);
      
      updateScore();
    }
  }

  function updateScore() {
    scoreElem.innerText = player.score;
    levelElem.innerText = player.level;
    linesElem.innerText = player.lines;
  }

  function drawGrid() {
    context.strokeStyle = '#333';
    context.lineWidth = 0.05;
    
    // 绘制垂直线
    for (let x = 0; x <= COLS; x++) {
      context.beginPath();
      context.moveTo(x, 0);
      context.lineTo(x, ROWS);
      context.stroke();
    }
    
    // 绘制水平线
    for (let y = 0; y <= ROWS; y++) {
      context.beginPath();
      context.moveTo(0, y);
      context.lineTo(COLS, y);
      context.stroke();
    }
  }

  function draw() {
    context.fillStyle = '#111';
    context.fillRect(0, 0, COLS, ROWS);

    drawGrid();
    drawMatrix(arena, {x:0, y:0});
    
    // 绘制当前方块
    drawMatrix(player.matrix.map(row => row.map(val => val ? player.color : 0)), player.pos);
    
    // 绘制阴影（预测落点）
    const shadow = { ...player.pos };
    while (!collide(arena, { matrix: player.matrix, pos: { x: shadow.x, y: shadow.y + 1 } })) {
      shadow.y++;
    }
    
    context.globalAlpha = 0.2;
    drawMatrix(player.matrix.map(row => row.map(val => val ? player.color : 0)), shadow);
    context.globalAlpha = 1.0;
  }

  function gameOver() {
    isPaused = true;
    gameOverElem.style.display = 'block';
    finalScoreElem.textContent = `得分: ${player.score}`;
  }

  function restartGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.level = 1;
    player.lines = 0;
    dropInterval = 1000;
    isPaused = false;
    gameOverElem.style.display = 'none';
    
    // 初始化下一个方块
    const pieceTypes = Object.keys(pieces);
    const type = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
    const piece = pieces[type];
    nextPiece = {
      matrix: piece.shape[0].map(row => row.slice()),
      color: piece.color,
      type: type,
      shapeIndex: 0
    };
    
    playerReset();
    updateScore();
    lastTime = 0;
    dropCounter = 0;
  }

  // 移动端触摸控制
  function setupMobileControls() {
    // 左移按钮
    mobileLeft.addEventListener('touchstart', function(e) {
      e.preventDefault();
      if (isPaused) return;
      player.pos.x--;
      if (collide(arena, player)) player.pos.x++;
    });

    // 右移按钮
    mobileRight.addEventListener('touchstart', function(e) {
      e.preventDefault();
      if (isPaused) return;
      player.pos.x++;
      if (collide(arena, player)) player.pos.x--;
    });

    // 旋转按钮
    mobileRotate.addEventListener('touchstart', function(e) {
      e.preventDefault();
      if (isPaused) return;
      playerRotate(1);
    });

    // 快速下落按钮
    mobileDrop.addEventListener('touchstart', function(e) {
      e.preventDefault();
      if (isPaused) return;
      
      // 加速下落
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        arenaSweep();
        playerReset();
      }
      dropCounter = 0;
    });

    // 防止页面滚动
    document.querySelector('.mobile-controls').addEventListener('touchmove', function(e) {
      e.preventDefault();
    }, { passive: false });
  }

  let dropCounter = 0;
  let dropInterval = 1000;
  let lastTime = 0;
  let isPaused = false;
  let nextPiece = null;

  const arena = createMatrix(COLS, ROWS);

  const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    color: null,
    type: null,
    shapeIndex: 0,
    score: 0,
    level: 1,
    lines: 0
  };

  function update(time = 0) {
    if (isPaused) {
      requestAnimationFrame(update);
      return;
    }
    
    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        arenaSweep();
        playerReset();
      }
      dropCounter = 0;
    }

    draw();
    requestAnimationFrame(update);
  }

  // 初始化下一个方块
  const pieceTypes = Object.keys(pieces);
  const type = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
  const piece = pieces[type];
  nextPiece = {
    matrix: piece.shape[0].map(row => row.slice()),
    color: piece.color,
    type: type,
    shapeIndex: 0
  };

  document.addEventListener('keydown', event => {
    if (isPaused && event.key !== 'p' && event.key !== 'P') return;
    
    if (['ArrowLeft', 'a', 'A'].includes(event.key)) {
      player.pos.x--;
      if (collide(arena, player)) player.pos.x++;
    }
    else if (['ArrowRight', 'd', 'D'].includes(event.key)) {
      player.pos.x++;
      if (collide(arena, player)) player.pos.x--;
    }
    else if (['ArrowDown', 's', 'S'].includes(event.key)) {
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        arenaSweep();
        playerReset();
      }
      dropCounter = 0;
    }
    else if (['ArrowUp', 'w', 'W'].includes(event.key)) {
      playerRotate(1);
    }
    else if (event.key === ' ') { // 空格键直接落底
      while (!collide(arena, { matrix: player.matrix, pos: { x: player.pos.x, y: player.pos.y + 1 } })) {
        player.pos.y++;
      }
      merge(arena, player);
      arenaSweep();
      playerReset();
      dropCounter = 0;
    }
    else if (event.key === 'p' || event.key === 'P') {
      isPaused = !isPaused;
      if (!isPaused) {
        lastTime = performance.now();
      }
    }
  });

  pauseBtn.addEventListener('click', () => {
    isPaused = !isPaused;
    if (!isPaused) {
      lastTime = performance.now();
    }
  });

  restartBtn.addEventListener('click', restartGame);
  restartBtn2.addEventListener('click', restartGame);

  // 设置移动端控制
  setupMobileControls();

  playerReset();
  updateScore();
  update();
})();
</script>
</body>
</html>
